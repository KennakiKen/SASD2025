# HW2: Code Smell – Incomplete Library Class 

## a. ความหมายของ Incomplete Library Class

Incomplete Library Class เป็น code smell ที่เกิดขึ้นเมื่อเราใช้งาน class จาก library ภายนอก  
แต่ class นั้น **ไม่มี method หรือความสามารถที่ตรงกับความต้องการของระบบเรา**  
ทำให้ต้องเขียนโค้ดเพิ่มเติมภายนอก class อยู่บ่อยครั้ง

ในภาษา C++ ปัญหานี้มักเกิดกับ class จาก STL หรือ library ที่เราไม่สามารถแก้ไข source code ได้  
จึงต้องหาวิธีขยายความสามารถของ class เหล่านั้นแทน

---

 ## b. ตัวอย่างโค้ดที่เกิด Incomplete Library Class

```cpp
class Person {
public:
    std::string getFirstName() const {
        return firstName;
    }

    std::string getLastName() const {
        return lastName;
    }

private:
    std::string firstName;
    std::string lastName;
};
```
แต่ในระบบของเรา ต้องการใช้งานชื่อเต็ม (Full Name)
ทำให้ต้องเขียนโค้ดซ้ำ ๆ ภายนอก class
```cpp
std::string fullName = person.getFirstName() + " " + person.getLastName();
```
กรณีนี้ถือว่า **Person เป็น Incomplete Library Class**
เพราะ class ไม่ได้เตรียม method ที่เหมาะสมกับการใช้งานจริงของระบบ

---

## c. ตัวอย่างโค้ดหลังจาก Refactoring

```cpp
class PersonWrapper {
public:
    PersonWrapper(const Person& person) : person(person) {}

    std::string getFullName() const {
        return person.getFirstName() + " " + person.getLastName();
    }

private:
    Person person;
};
```
- การ refactoring ลักษณะนี้ช่วยรวม logic ที่เกี่ยวข้องไว้ในที่เดียว
- ลดการเขียนโค้ดซ้ำ ทำให้โค้ดอ่านง่ายและดูเป็นระบบมากขึ้น

---

## d.กรณีที่ code smell นี้ไม่ได้บ่งบอกถึงโค้ดที่มีปัญหา(กรณีที่ไม่จำเป็นต้อง refactoring)

Incomplete Library Class ไม่ได้หมายความว่าโค้ดผิดเสมอไป
ในบางกรณีอาจไม่จำเป็นต้อง refactoring เช่น:

- ใช้งาน logic ที่ขาดไปเพียงเล็กน้อยหรือเพียงครั้งเดียว
- Logic มีความเฉพาะเจาะจงกับบางส่วนของระบบ
- การเพิ่ม Wrapper Class ทำให้โค้ดซับซ้อนเกินความจำเป็น

ตัวอย่างกรณีที่ไม่ควร refactoring:
```cpp
std::string shortName = person.getFirstName().substr(0, 1);
```
ในกรณีนี้ การสร้าง class เพิ่มอาจไม่คุ้มค่าเมื่อเทียบกับความซับซ้อนที่เพิ่มขึ้น
